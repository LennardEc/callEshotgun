callEshotgun(Xtr, Ytr, c(-5), c(5), 15L, 0.1),
NULL
)
# Edit the Ytr-Matrix to provoke a error
Xtr <- matrix(runif(20),ncol=1)
Ytr <- modifiedLevy(Xtr)
testthat::expect_equal(
callEshotgun(Xtr, Ytr, c(-5), c(5), 25L, 0.1),
NULL
)
print(callEshotgun(Xtr, Ytr, c(-5), c(5), 25L, 0.1))
Xtr <- matrix(runif(20),ncol=1)
Ytr <- sphere(Xtr)
#working
newX <-callEshotgun(Xtr, Ytr, c(-5.12), c(5.12), 10L, 0.2)
testthat::expect_equal(
ncol(newX), ncol(Xtr)
)
Xtr <- matrix(runif(20),ncol=1)
Ytr <- sphere(Xtr)
newX <-callEshotgun(Xtr, Ytr, c(-5.12), c(5.12), 10L, 0.2)
testthat::expect_equal(
ncol(newX), ncol(Xtr)
)
Xtr <- matrix(runif(20),ncol=1)
Ytr <- sphere(Xtr)
#working
newX <-callEshotgun(Xtr, Ytr, c(-5.12), c(5.12), 20L, 0.2)
testthat::expect_equal(
ncol(newX), ncol(Xtr)
)
#10 points get evaluaded
testthat::expect_equal(
nrow(newX) + 10 , nrow(Xtr)
)
Xtr <- matrix(runif(20),ncol=1)
Ytr <- sphere(Xtr)
#working
newX <-callEshotgun(Xtr, Ytr, c(-5.12), c(5.12), 20L, 0.2)
testthat::expect_equal(
ncol(newX), ncol(Xtr)
)
#10 points get evaluaded
testthat::expect_equal(
nrow(newX), nrow(Xtr)
)
#working
Xtr <- matrix(runif(20),ncol=2)
Ytr <- sphere(Xtr)
#working
newX <- callEshotgun(Xtr, Ytr, c(-5.12,-1), c(5.12, 0), 10L, 0.1)
testthat::expect_equal(
nrow(newX), nrow(Xtr)
)
Ytr <- sphere(Xtr)
#working
Xtr <- matrix(runif(20),ncol=2)
Ytr <- sphere(Xtr)
#working
newX <- callEshotgun(Xtr, Ytr, c(-5.12,-1), c(5.12, 0), 10L, 0.1)
testthat::expect_equal(
nrow(newX), nrow(Xtr)
)
library(CallEshotgun)
#working
Xtr <- matrix(runif(20),ncol=2)
Ytr <- sphere(Xtr)
#working
newX <- callEshotgun(Xtr, Ytr, c(-5.12,-1), c(5.12, 0), 10L, 0.1)
testthat::expect_equal(
nrow(newX), nrow(Xtr)
)
Xtr <- matrix(runif(20),ncol=2)
Ytr <- sphere(Xtr)
#working
newX <- callEshotgun(Xtr, Ytr, c(-5.12,-1), c(5.12, 0), 10L, 0.1)
library(CallEshotgun)
devtools::document()
library(CallEshotgun)
Xtr <- matrix(runif(20),ncol=2)
Ytr <- sphere(Xtr)
#' egg
#'
#' @param xx Vector
#'
#' @return a atom
#' @export
#'
#' @examples
egg <- function(xx) {
##########################################################################
#
# EGGHOLDER FUNCTION
#
# Authors: Sonja Surjanovic, Simon Fraser University
#          Derek Bingham, Simon Fraser University
# Questions/Comments: Please email Derek Bingham at dbingham@stat.sfu.ca.
#
# Copyright 2013. Derek Bingham, Simon Fraser University.
#
# THERE IS NO WARRANTY, EXPRESS OR IMPLIED. WE DO NOT ASSUME ANY LIABILITY
# FOR THE USE OF THIS SOFTWARE.  If software is modified to produce
# derivative works, such modified software should be clearly marked.
# Additionally, this program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 2.0 of the License.
# Accordingly, this program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# For function details and reference information, see:
# http://www.sfu.ca/~ssurjano/
#
##########################################################################
#
# INPUT:
#
# xx = c(x1, x2)
#
##########################################################################
x1 <- xx[1]
x2 <- xx[2]
term1 <- -(x2+47) * sin(sqrt(abs(x2+x1/2+47)))
term2 <- -x1 * sin(sqrt(abs(x1-(x2+47))))
y <- term1 + term2
return(y)
}
#' modifiedEgg
#'
#' @param x vector
#'
#' @return a matrix
#' @export
#'
#' @examples
modifiedEgg <- function(x) {
matrix(apply(x, # matrix
1, # margin (apply over rows)
function(x){
egg(x)
}),
, 1) # number of columns
}
#' schwef
#'
#' @param xx vector
#'
#' @return a atom
#' @export
#'
#' @examples
schwef <- function(xx) {
##########################################################################
#
# SCHWEFEL FUNCTION
#
# Authors: Sonja Surjanovic, Simon Fraser University
#          Derek Bingham, Simon Fraser University
# Questions/Comments: Please email Derek Bingham at dbingham@stat.sfu.ca.
#
# Copyright 2013. Derek Bingham, Simon Fraser University.
#
# THERE IS NO WARRANTY, EXPRESS OR IMPLIED. WE DO NOT ASSUME ANY LIABILITY
# FOR THE USE OF THIS SOFTWARE.  If software is modified to produce
# derivative works, such modified software should be clearly marked.
# Additionally, this program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 2.0 of the License.
# Accordingly, this program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# For function details and reference information, see:
# http://www.sfu.ca/~ssurjano/
#
##########################################################################
#
# INPUT:
#
# xx = c(x1, x2, ..., xd)
#
##########################################################################
d <- length(xx)
sum <- sum(xx*sin(sqrt(abs(xx))))
y <- 418.9829*d - sum
return(y)
}
#' modifiedschwef
#'
#' @param x vector
#'
#' @return a matrix
#' @export
#'
#' @examples
modifiedschwef <- function(x) {
matrix(apply(x, # matrix
1, # margin (apply over rows)
function(x){
schwef(x)
}),
, 1) # number of columns
}
#' levy
#'
#' @param xx vector
#'
#' @return a atom
#' @export
#'
#' @examples
levy <- function(xx) {
##########################################################################
#
# LEVY FUNCTION
#
# Authors: Sonja Surjanovic, Simon Fraser University
#          Derek Bingham, Simon Fraser University
# Questions/Comments: Please email Derek Bingham at dbingham@stat.sfu.ca.
#
# Copyright 2013. Derek Bingham, Simon Fraser University.
#
# THERE IS NO WARRANTY, EXPRESS OR IMPLIED. WE DO NOT ASSUME ANY LIABILITY
# FOR THE USE OF THIS SOFTWARE.  If software is modified to produce
# derivative works, such modified software should be clearly marked.
# Additionally, this program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 2.0 of the License.
# Accordingly, this program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# For function details and reference information, see:
# http://www.sfu.ca/~ssurjano/
#
##########################################################################
#
# INPUT:
#
# xx = c(x1, x2, ..., xd)
#
##########################################################################
d <- length(xx)
w <- 1 + (xx - 1)/4
term1 <- (sin(pi*w[1]))^2
term3 <- (w[d]-1)^2 * (1+1*(sin(2*pi*w[d]))^2)
wi <- w[1:(d-1)]
sum <- sum((wi-1)^2 * (1+10*(sin(pi*wi+1))^2))
y <- term1 + sum + term3
return(y)
}
#' modifiedlevy
#'
#' @param x vector
#'
#' @return a matrix
#' @export
#'
#' @examples
modifiedLevy <- function(x) {
matrix(apply(x, # matrix
1, # margin (apply over rows)
function(x){
levy(x)
}),
, 1) # number of columns
}
#' @param b double
#' @param c double
#' @param r double
#' @param s double
#' @param t double
#'
#' @return a matrix
#' @export
#'
#' @examples
branin <- function(xx, a=1, b=5.1/(4*pi^2), c=5/pi, r=6, s=10, t=1/(8*pi)) {
##########################################################################
#
# BRANIN FUNCTION
#
# Authors: Sonja Surjanovic, Simon Fraser University
#          Derek Bingham, Simon Fraser University
# Questions/Comments: Please email Derek Bingham at dbingham@stat.sfu.ca.
#
# Copyright 2013. Derek Bingham, Simon Fraser University.
#
# THERE IS NO WARRANTY, EXPRESS OR IMPLIED. WE DO NOT ASSUME ANY LIABILITY
# FOR THE USE OF THIS SOFTWARE.  If software is modified to produce
# derivative works, such modified software should be clearly marked.
# Additionally, this program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 2.0 of the License.
# Accordingly, this program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# For function details and reference information, see:
# http://www.sfu.ca/~ssurjano/
#
##########################################################################
#
# INPUTS:
#
# xx = c(x1, x2)
# a = constant (optional), with default value 1
# b = constant (optional), with default value 5.1/(4*pi^2)
# c = constant (optional), with default value 5/pi
# r = constant (optional), with default value 6
# s = constant (optional), with default value 10
# t = constant (optional), with default value 1/(8*pi)
#
##########################################################################
x1 <- xx[1]
x2 <- xx[2]
term1 <- a * (x2 - b*x1^2 + c*x1 - r)^2
term2 <- s*(1-t)*cos(x1)
y <- term1 + term2 + s
return(y)
}
#' modifiedBranin
#'
#' @param x vector
#'
#' @return a matrix
#' @export
#'
#' @examples
modifiedBranin <- function(x) {
matrix(apply(x, # matrix
1, # margin (apply over rows)
function(x){
branin(x)
}),
, 1) # number of columns
}
Ytr <- sphere(Xtr)
sphere <- function (x) {
matrix(apply(x, # matrix
1, # margin (apply over rows)
function(x) {
sum(x ^ 2)  # objective function
}),
, 1) # number of columns
}
Ytr <- sphere(Xtr)
View(Xtr)
View(Ytr)
Xtr <- matrix(runif(20),ncol=2)
Ytr <- sphere(Xtr)
# right dimension, legal values
testthat::expect_type(
callEshotgun(Xtr, Ytr, c(-5.12,-1, -2), c(5.12, 0), 10L, 0.1),
typeof(Xtr)
)
source('C:/Users/Lennard/IDE/praxisprojekt/rshotgunsmall/R/CallEshotgun.R')
Xtr <- matrix(runif(20),ncol=2)
Ytr <- sphere(Xtr)
# right dimension, legal values
testthat::expect_type(
callEshotgun(Xtr, Ytr, c(-5.12,-1, -2), c(5.12, 0), 10L, 0.1),
typeof(Xtr)
)
library(CallEshotgun)
Xtr <- matrix(runif(20),ncol=2)
Ytr <- sphere(Xtr)
# right dimension, legal values
testthat::expect_type(
callEshotgun(Xtr, Ytr, c(-5.12,-1,-1), c(5.12, 0), 10L, 0.1),
typeof(Xtr)
)
# right dimension, legal values
testthat::expect_type(
callEshotgun(Xtr, Ytr, c(-4,-5), c(-3,1), 10L, 0.1)
, typeof(Xtr)
)
#wrong dimension
testthat::expect_equal(
callEshotgun(Xtr, Ytr, c(-5.12,-1), c(5.12, 0, 1), 10L, 0.1)
, NULL
)
#values are not strictly smaller
testthat::expect_equal(
callEshotgun(Xtr, Ytr, c(1,1), c(1,1), 10L, 0.1)
, NULL
)
#values are not strictly smaller
testthat::expect_equal(
callEshotgun(Xtr, Ytr, c(0,1), c(2,1), 10L, 0.1)
, NULL
)
#value of lower bound is bigger than the value of the upper bound
testthat::expect_equal(
callEshotgun(Xtr, Ytr, c(0,3), c(2,2), 10L, 0.1)
, NULL
)
library(CallEshotgun)
source('C:/Users/Lennard/IDE/praxisprojekt/rshotgunsmall/R/CallEshotgun.R')
source('C:/Users/Lennard/IDE/praxisprojekt/rshotgunsmall/R/testFunctions.R')
Xtr <- matrix(runif(20),ncol=3)
Ytr <- modifiedBranin(Xtr)
print(callEshotgun(Xtr, Ytr, c(-5,-4,-3), c(5,6,7), 10L, 2.0))
Xtr <- matrix(runif(20),ncol=3)
Ytr <- modifiedBranin(Xtr)
Xtr <- matrix(runif(20),ncol=3)
Ytr <- modifiedBranin(Xtr)
Xtr <- matrix(runif(20),ncol=2)
Ytr <- modifiedBranin(Xtr)
Xtr <- matrix(runif(20),ncol=3)
Ytr <- modifiedBranin(Xtr)
Xtr <- matrix(runif(20),ncol=2)
Ytr <- modifiedBranin(Xtr)
Xtr <- matrix(runif(20),ncol=1)
Ytr <- modifiedLevy(Xtr)[1:8]
testthat::expect_equal(
callEshotgun(Xtr, Ytr, c(-5), c(5), 10L, 0.1),
NULL
)
Xtr <- matrix(runif(20),ncol=1)
Ytr <- modifiedLevy(Xtr)#[1:8]
Xtr <- matrix(runif(20),ncol=2)
Ytr <- sphere(Xtr)
Xtr <- matrix(runif(20),ncol=2)
Ytr <- sphere(Xtr)
Xtr <- matrix(runif(20),ncol=2)
Ytr <- sphere(Xtr)
Xtr <- matrix(runif(20),ncol=2)
Ytr <- sphere(Xtr)[1:8]
callEshotgun(Xtr, Ytr, c(-5.12,-1), c(5.12, 0), 10L, 0.1)
library(CallEshotgun)
library(CallEshotgun)
?levy
#' egg
#'
#'
#' @param xx Vector
#'
#' @return y an single
#' @export
#'
#' @examples
egg <- function(xx) {
x1 <- xx[1]
x2 <- xx[2]
term1 <- -(x2+47) * sin(sqrt(abs(x2+x1/2+47)))
term2 <- -x1 * sin(sqrt(abs(x1-(x2+47))))
y <- term1 + term2
return(y)
}
#'# xx = c(x1, x2, x3, x4, x5, x6)
#'#
#'##########################################################################
#'
#' @param x Vector x = c(x1, x2, x3, x4, x5, x6)
#'
#' @return a matrix with the sphere function applied to each row
#' @export
#'
#' @examples
sphere <- function (x) {
matrix(apply(x, # matrix
1, # margin (apply over rows)
function(x) {
sum(x ^ 2)  # objective function
}),
, 1) # number of columns
}
#'#
#'##########################################################################
#'
#'
#' @param xx Vector with two elements xx = c(x1, x2)
#'
#' @return y an single double
#' @export
#'
#' @examples
egg <- function(xx) {
x1 <- xx[1]
x2 <- xx[2]
term1 <- -(x2+47) * sin(sqrt(abs(x2+x1/2+47)))
term2 <- -x1 * sin(sqrt(abs(x1-(x2+47))))
y <- term1 + term2
return(y)
}
devtools::document()
?levy
py_config()
devtools::document()
R --version
version[['version.string']]
sessionInfo()
library(CallEshotgun)
devtools::document()
print(toTitleCase("Providing an interface to the e-shotgun algorithm for bayesian optimization"))
print(tools::toTitleCase("Providing an interface to the e-shotgun algorithm for bayesian optimization"))
library(CallEshotgun)
document::check() --as-cran
devtools::check() --as-cran
ls
getwd()
setwd("C:/Users/Lennard/IDE/praxisprojekt/rshotgunsmall")
setwd("C:/Users/Lennard/IDE/praxisprojekt")
R CMD check --as-cran CallEshotgun_0.1.0.tar.gz
install.packages("testthat")
install.packages("testthat")
library(CallEshotgun)
